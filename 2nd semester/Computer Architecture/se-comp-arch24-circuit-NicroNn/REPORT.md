| Лабораторная работа №2     | M3104                         | АОВС |
|----------------------------|-------------------------------| ---- |
| Построение логических схем | Каренин Константин Витальевич | 2024 |

> [!important]  
> Не забудьте указать в шапке свои ФИО и Номер группы

## Инструментарий

> icarus verilog v12

## Вариант

> logisim normal, behaviour verilog normal, structural verilog normal

## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-circuit-NicroNn/actions/runs/8527692869)

# Описание

> Раздел, в котором вы описываете свою реализацию:
> 
> Что за схема вам дана, как она работает.
> 
> Как она была реализована (сколько ячеек памяти вы по итогу использовали, как "под капотом" работает ваша схема).
> 
> Если в вашей схеме реализованы также (де)мультиплексоры, триггеры и прочие непростые логических схемы, то нужно также расписать как они работают и зачем были использованы (коротко: что это такое и принцип работы, можно приводить таблицы истинности и временные диаграммы).
> 
> Если реализуется normal, то нужно описать как работают входовыходы и работа с 5 ячейками памяти (учитывая, что индекс может принимать значения от 0 до 7 включительно).
> Отдельно описать особенности сборки на Logisim, отдельно – на SystemVerilog.
## Logisim
**D_trigger:**
состоит из двух инверторов (или непосредственно/задержки) и двух логических И элементов. Вход D (Data) определяет, какая
информация будет записана в триггер, а вход С (Clock) определяет момент времени, когда данные будут записаны. При каждом
положительном или отрицательном фронте тактового сигнала данные на входе D копируются на выход Q (Output), что позволяет
триггеру запоминать информацию. \
**JK_trigger:**
состоит из двух инверторов (или непосредственно/задержки) и двух логических И элементов. У JK-триггера есть два входа 
данных, обозначаемых как J и K. Вход J (set) устанавливает триггер в состояние "1", вход K (reset) сбрасывает триггер в 
состояние "0". Если оба входа J и K равны "0", то состояние триггера остаётся неизменным. Также, у JK-триггера есть 
тактовый вход С (Clock), который определяет момент времени записи данных, а также переключает состояние триггера при 
изменении данных на входах J и K в момент тактового импульса. \
**module5:**
остаток деления числа на 5, нужен для index, т.к. index 3-х битный (тоесть значения от 0 до 7), а стек на 5 ячеек. \
**memory4bit:**
4-х битная ячейка памяти основанная на D_trigger'е, используется для хранения чисел в стеке. \
**check0-4:**
используются для получения элемента по индексу. \
**convertor:**
сдвигает index на заданную позицию (по сути - (element1 + (5 - element2)) mod 5) \
**convertor_minus:**
аналогично convertor'у только сдвигает назад. \
**result:**
объединяет элементы стека для вывода. \
**checker:**
нужен для проверки следующего выражения: \
(введеный индекс == индекс ячейки) И (введенная команда == 10)
ИЛИ (вычисленный converter индекс) И (введенная команда == 11) \
**indicator:**
на основе CLK и RESET общих для всего стека оределяет нужно ли вообще изменять значенеие каких-либо ячеек. 
И если необходимо изменение, возварщает индекс. \
**sub_stack:**
на основе входных данных и используя выше описанные модули заносит число в нужную ячейку памяти, а также передает на
выходы значения во всех ячейках.\
**transmission gate:**
гейт похожий на реле, который может проводить ток в обоих направлениях или 
блокироваться управляющим сигналом практически с любым потенциалом напряжения.[1] Это переключатель на основе CMOS, в 
котором PMOS передает сильный 1, но плохой 0, а NMOS передает сильный 0, но плохой 1. И PMOS, и NMOS работают одновременно.
Transmission gate позволяет мультиплексировать несколько потоков данных в один канал в схеме stack.
## SystemVeriLog Behaviour
### Описание схемы
Схема stack_behaviour_normal представляет собой модель стека, реализованную на 5 ячейках памяти. Она имеет следующие интерфейсы:

**IO_DATA**: 4-битный вход/выход для данных \
**RESET**: Асинхронный сброс \
**CLK**: Тактовый сигнал \
**COMMAND**: 2-битный вход для управления командами \
**INDEX**: 3-битный вход для задания индекса ячейки памяти \
### Реализация схемы
Регистры:

**mas[4:0]**: массив из 5 регистров для хранения данных \
**index**: регистр для хранения индекса текущей ячейки \
**index2**: регистр для хранения индекса следующей ячейки \
**rw**: регистр флага чтения/записи \
**res**: регистр для хранения результата операции \
**temp**: регистр для временного хранения индекса 

Работа схемы:
1. Сброс: При сбросе все регистры инициализируются нулем.
2. Запись:

   Команда 01 (push): Записывает данные из IO_DATA в ячейку, адрес которой задается регистром index. \
   Индекс index и index2 увеличиваются на 1 после записи, если при увеличении индекс = 5, то сбрасываем его до 0 (т.к стек на 5 элементов, а числа могут быть от 0 до 7).
3. Чтение:

   Команда 10 (pop): Читает данные из ячейки, адрес которой задается регистром index2. \
   Результат чтения помещается в регистр res. \
   Индекс index и index2 уменьшаются на 1 после чтения, если индекс 0 то делаем его 4.
4. Случайный доступ:

   Команда 11 (get): Читает данные из ячейки, адрес которой задается 3-битным кодом на входе INDEX, если он больше 4 то уменьшаем его на 5 (т.к стек на 5 элементов, а числа могут быть от 0 до 7). \
   Результат чтения помещается в регистр res. 

## SystemVeriLog Structural

**1. module5 (A0, A1, A2, S0, S1, S2, S3, S4)**

**Функциональность:**

- Принимает три входных бита (`A0`, `A1`, `A2`).
- Выполняет операцию modulo 5 над двоичным значением, которое они представляют.
- Выводит результат в виде пяти выходных битов (`S0` to `S4`).

**Таблица истинности:**

| A2 | A1 | A0 | S0 | S1 | S2 | S3 | S4 |
|---|---|---|---|---|---|---|---|
| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | 0 | 1 | 0 | 0 |

**Реализация:**

- Использует три `and`-гейта (`result0` to `result4`) для генерации термов произведения для каждого выходного бита.
- Каждый терм произведения представляет собой конкретная комбинация входных битов, которая удовлетворяет условию, при котором конкретный выходной бит равен 1.
- Выходы элементов `and` подключены к выходным битам (от `S0` до `S4`).

**2. decrModule5 (A0, A1, A2, B0, B1, B2)**

**Функциональность:**

- Принимает 3-битное двоичное значение (`A0`, `A1`, `A2`).
- Уменьшает входное значение на 1 (modulo 5).
- Выводит декрементированное значение как 3-битное двоичное значение (`B0`, `B1`, `B2`).

**Реализация:**

- Инстанциирует модуль `module5` (`ttf1`) для преобразования входного значения (`A0`, `A1`, `A2`) в пять выходных битов (`T0` to `T4`).
- Использует модуль `getBinIndex` (`fft1`) для отображения пяти выходных битов (`T0` to `T4`) обратно в 3-битное двоичное представление, представляющее декрементированное значение (`B0`, `B1`, `B2`).
- Внутри модуль выполняет серию операций уменьшения, используя модуль `decrement` (от m0 до m3). Эти модули обрабатывают поведение по модулю 5, используя функциональность `module5`.

**3. getBinIndex (A0, A1, A2, S0, S1, S2, S3, S4)**

**Функциональность:**

- Принимает пять входных битов (`S0` to `S4`).
- Выводит 3-битное двоичное представление, основанное на бите с наивысшим значением (1) во входных данных.
- Определяет индекс наиболее значащего 1-бита во входных данных.

**Реализация:**

- Использует два `or`-гейта (`OR0` and `OR1`) to determine if `S1` or `S2` is 1.
- Использует `or`-гейт (`OR2`) to determine if `S4` is 1.
- Outputs `A0` as 1 if `S1` is 1, or `A1` as 1 if `S2` is 1, or `A2` as 1 if `S4` is 1.

**4. increment (B0, B1, B2, A0, A1, A2)**

**Функциональность:**

- Принимает 3-битное двоичное значение (`A0`, `A1`, `A2`).
- Увеличивает входное значение на 1 (по модулю 5).
- Выводит увеличенное значение как 3-битное двоичное значение (B0, B1, B2).


**5. decrement (B0, B1, B2, A0, A1, A2)**

Функциональность:

- Похож на increment, но вместо этого уменьшает входное значение на 1 (по модулю 5).

**6. indicator (INF1, INF2, CMD0, CMD1)**

Функциональность:

- Определяет, указывают ли входные команды (CMD0 and CMD1) на операцию push или pop.
- Выводит два индикаторных бита (INF1 and INF2), которые используются для управления операциями стека.

Реализация:

- Использует xor-гейт (make_xorOps) для определения, разные ли команды.
- Использует not-гейт (make_not_xorOps) для инвертирования результата XOR.
- Использует два or-гейта (make_inf1 and make_inf2) для генерации индикаторных битов на основе результата XOR и команд.

**7. D_trigger (Q, C, D)**

Функциональность:

- Реализует D-триггер.
- Хранит один бит данных (D).
- Обновляет свой выход (Q) по фронту синхросигнала (C).

Реализация:

- Использует два and-гейта (IN1 and IN2) для управления потоком данных.
- Использует два nor-гейта (NOR1 and NOR2) для реализации логики триггера.

**8. pusher (Out0, Out1, Out2, In0, In1, In2, B)**

Функциональность:

- Выводит входные биты (In0, In1, In2), если бит управления (B) равен 1, или 0 в противном случае.
- Используется для push данных в стек.

Реализация:

- Использует три and-гейта (AND1, AND2, AND3) для объединения входных битов (In0, In1, In2) с битом управления (B).
- Выводит результат and-вентилей как Out0, Out1, Out2.

**10. stack (DATA_OUT, DATA_IN, POP, PUSH, RESET, CLOCK)**

Функциональность:

- Хранит данные в порядке LIFO (last-in-first-out).
- Push данные в стек, когда PUSH 1.
- Pop данные из стека, когда POP 1.
- Сбрасывает стек, когда RESET 1.

Реализация:

- Инстанциирует все остальные модули и соединяет их вместе.
- Использует модуль D_trigger для хранения указателя стека.
- Использует модуль pusher для push данных в стек.
- Использует модуль popper для pop данных из стека.
- Использует модуль indicator для определения типа операции.
- Использует модуль decrement для уменьшения указателя стека при pop.
- Использует модуль increment для увеличения указателя стека при push.


### Примечания по оформлению (можно удалить после создания отчёта)

1. Не нужно вставлять своё описание как quote (цитату). 
2. Старайтесь также разбивать ваш текст на логические разделы и отделять мысли заголовками.
3. Если хочется вставить фрагменты кода, то делаете это блоком кода. Если же ссылаетесь на код, то рекомендуется это делать через permalink на файлы в репозитории.
4. Можно пользоваться всеми возможностями Github Markdown.
5. Никаких фоток в отчёте, ровно как и скринов полного экрана. Это больно смотреть \(
6. Если вы хотите вставить изображение из сети, то не нужно его грузить в репозиторий.
7. В случае описание подсхем Logisim, если вы просто ссылаетесь на подсхему в целом, то достаточно указать назвнаие подсхемы из проекта. Если же вы описываете какой-то небольшой фрагмент схемы, то лучше его вставить в виде рисунка в отчёт.
